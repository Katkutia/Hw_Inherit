als(expected, actual);
    }
```

Теперь давайте добавим в менеджер возможность искать задачи по посковому запросу (`query`).
Подходит ли задача запросу, будет решать сама задача, для чего мы в `Task` заведём метод `matches`.

```java
    /**
     * Метод, проверяющий подходит ли эта задача поисковому запросу.
     * Эта логика должна быть определена в наследниках, у каждого она будет своя
     * @param query Поисковый запрос
     * @return Ответ на вопрос, подходит ли эта задача под поисковый запрос
     */
    public boolean matches(String query) {
        return false;
    }
```

В каждом же наследнике мы переопределим этот метод так, чтобы:

* `SimpleTask` подходил, если запрос `query` встречается в `title`;
* `Epic` подходил, если запрос `query` встречается хотя бы в одной из подзадач;
* `Meeting` подходил, если запрос `query` встречается в `topic` или `project`.

Рассмотрим на примере переопределения этого метода для класса `Meeting`.
Мы воспользуемся методом `contains`, который есть у каждого объекта типа `String`: `s1.contains(s2)` отвечает на вопрос, содержится ли текст из `s2` в тексте из `s1`.
В итоге мы может переопределить метод так:

```java
    @Override
    public boolean matches(String query) {
        if (topic.contains(query)) {
            return true;
        }
        if (project.contains(query)) {
            return true;
        }
        return false;
    }
```

Переопределите метод `matches` для двух оставшихся классов.
Для `SimpleTask` это можно сделать одним if, для `Epic` — циклом перебирая подзадачи и также проверяя каждую через `if`.
Напишите тесты на метод `matches` для всех трёх классов, поместите их в `TasksTest`-классе.

Теперь мы можем добавить метод поиска в сам класс `Todos`:
```java
    /**
     * Метод поиска задач, которые подходят под поисковый запрос
     * @param query Поисковый запрос
     * @return Массив из подошедших задач
     */
    public Task[] search(String query) {
        Task[] result = new Task[0]; // массив для ответа
        for (Task task : tasks) { // перебираем все задачи
            if (task.matches(query)) { // если задача подходит под запрос
                result = addToArray(result, task); // добавляем её в массив ответа
            }
        }
        return result;
    }
```

Напишите тесты на метод поиска в классе `TodosTest`.

Как видите, благодаря наследованию и полиморфизму, мы смогли создать менеджер задач, который работал бы с любыми типами задач.
Мы можем создать их ещё хоть сто разных видов, и менеджер менять для этого не потребуется.

------

## Правила приёма работы

Прикреплена ссылка на публичный репозиторий с решением задачи.

------

## Критерии оценки

1. В каждом репозитории размещено содержимое папки проекта IDEA. Корнем репозитория должна быть именно папка проекта — не папка `src`, не папка, внутри которой лежит папка проекта. В корне репозитория должна лежать сразу папка `src`.
1. Есть файл `.gitignore`, игнорирующий ненужные файлы и папки, которые должны отсутствовать в репозитории. Если они там есть, их нужно оттуда удалить.
1. Программа соответствует всем требованиям из условия задачи.
1. Программа использует только те инструменты языка, которые мы проходили или которые прямо разрешены условием задачи.
1. Программа работает правильно на всех примерах из условия.
1. Программный код отформатирован и соответствует пройденным требованиям к качеству кода.
1. При запуске `mvn clean verify` тесты запускаются и проходят, а сборка завершается успешно.
2. В репозитории настроен CI на основе Github Actions, и он успешно прошёл на последнем коммите.
3. Программа спроектирована достаточно логично и правильно, не противоречит общепринятым в производстве практикам и традициям.
4. При наличии недочётов, в зависимости от их серьёзности и количества, работа может быть отправлена на доработку или принята. Решение принимается на основе экспертной оценки работы.
